// @author    Matthew Warren & Christopher Schmitt
// @version   1.23.2020
// @licence   MIT (c) @author


/**
 * The half adder performs addition of numbers.  It uses a
 * single XOR gate to compute the sum and a single and gate
 * to compute the carry.
 *
 * @param {wire} lhs - The left hand side
 * @param {wire} rhs - The right hand side
 * @return {wire} sum - The sum of lhs + rhs
 * @return {wire} cout - The carry of lhs + rhs
 */
module HalfAdder(
  input wire lhs,
  input wire rhs,
  output wire sum,
  output wire cout
);

  // Compute sum
  xor(sum, lhs, rhs);

  // Comput cout
  and(cout, lhs, rhs);

endmodule // HalfAdder


/**
 * The adder combines two half adders to produce a single
 * circuit which accepts three inputs: carry in, lhs, and
 * rhs.
 *
 * @param {wire} cin - The carry in
 * @param {wire} lhs - The left hand side
 * @param {wire} rhs - The right hand side
 * @return {wire} sum - The sum of lhs + rhs
 * @return {wire} cout - The sum of lhs + rhs
 */
module Adder(
  input wire cin,
  input wire lhs,
  input wire rhs,
  output wire sum,
  output wire cout
);

  // Instantiate two half-adders
  HalfAdder halfAdderA(cin, lhs, buffer, carry_left);
  HalfAdder halfAdderB(buffer, rhs, sum, carry_right);

  // Compute cout
  or(cout, carry_left, carry_right);

endmodule // Adder


/**
 * The TwoOneMux selects one out of two input lines to
 * forward to the output line.
 *
 * @param {wire} select - Selects the input to forward
 * @param {wire [1:0]} data - The inputs to select from
 * @return {wire} result - The selected input
 */
module TwoOneMux(
  input wire select,
  input wire [1:0] data,
  output wire result
);

  // Invert select line
  not(select_, select);
  
  // Compute products
  and(lhs, data[0], select_);
  and(rhs, data[1], select);

  // Compute sum
  or(result, lhs, rhs);

endmodule // TwoOneMux


/**
 * The FourOneMux cascades several TwoOneMuxs together to
 * create a mux which selects between four inputs.
 *
 * @param {wire [1:0]} select - Selects the input to be forwarded
 * @param {wire [3:0]} data - The inputs to select from
 * @return {wire} result - The selected input
 */
module FourOneMux(
  input wire [1:0] select,
  input wire [3:0] data,
  output wire result
);

  // Instantiate layer one
  TwoOneMux muxA(select[0], {data[0], data[1]}, AB);
  TwoOneMux muxB(select[0], {data[2], data[3]}, BC);

  // Instantiate layer two
  TwoOneMux muxC(select[1], {AB, BC}, result);

endmodule // FourOneMux


/**
 * The OneBitALU performs basic arithmetic and logical
 * operations on all except for the most significant bit.
 *
 * @param {wire} lhs - The left hand side of the computation
 * @param {wire} rhs - The right hand side of the computation
 * @param {wire} cin - The carry in from the computaion of previous bits
 * @param {wire} less - The less input for the slt operation
 * @param {wire} rhs_invert - Inverts the rhs (used for inverse operations)
 * @param {wire [1:0]} op - The opcode representing the operation to perform
 * @return {wire} result - The result of the computaion
 * @return {wire} cout - The carry out of the compuation (if applicable)
 */
module OneBitALU(
  input wire lhs,
  input wire rhs,
  input wire cin,
  input wire less,
  input wire rhs_invert,
  input wire [1:0] op,
  output wire result
  output wire cout,
);

  // Handle rhs inversion
  not(rhs_, rhs);
  TwoOneMux inverter(rhs_invert, {rhs_, rhs}, rhs_inverted);

  // Compute lhs & rhs
  and(lhs_and_rhs, lhs, rhs);

  // Compute lhs | rhs
  or(lhs_or_rhs, lhs, rhs);

  // Compute lhs + rhs
  Adder adder(cin, lhs, rhs_inverted, sum, cout);

  // Select operation based on opcode
  FourOneMux selector(op, {lhs_and_rhs, lhs_or_rhs, sum, less}, result);

endmodule // OneBitALU


/**
 * The OneBitALU_MSB performs basic arithmetic and logical
 * operations on the most significant bit.
 *
 * @param {wire} lhs - The left hand side of the computation
 * @param {wire} rhs - The right hand side of the computation
 * @param {wire} cin - The carry in from the computaion of previous bits
 * @param {wire} less - The less input for the slt operation
 * @param {wire} rhs_invert - Inverts the rhs (used for inverse operations)
 * @param {wire [1:0]} op - The opcode representing the operation to perform
 * @return {wire} result - The result of the computaion
 * @return {wire} sum - The sum of the most significant bits of lhs and rhs
 * @return {wire} cout - The carry out of the compuation (if applicable)
 */
module OneBitALU_MSB(
  input wire lhs,
  input wire rhs,
  input wire cin,
  input wire less,
  input wire rhs_invert,
  input wire [1:0] op,
  output wire result,
  output wire sum,
  output wire cout
);

  // Handle rhs inversion
  not(rhs_, rhs);
  TwoOneMux inverter(rhs_invert, {rhs_, rhs}, rhs_inverted);

  // Compute lhs & rhs
  and(lhs_and_rhs, lhs, rhs);

  // Compute lhs | rhs
  or(lhs_or_rhs, lhs, rhs);

  // Compute lhs + rhs
  Adder adder(cin, lhs, rhs_inverted, sum, cout);

  // Select operation based on opcode
  FourOneMux selector(op, {lhs_and_rhs, lhs_or_rhs, sum, less}, result);

endmodule // OneBitALU_MSB